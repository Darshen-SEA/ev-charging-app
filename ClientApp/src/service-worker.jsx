/* eslint-disable no-restricted-globals */

// This service worker provides offline capabilities and caching for the EV Charging Station Manager app

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from "workbox-strategies"
import { CacheableResponsePlugin } from "workbox-cacheable-response"

// Take control of all clients as soon as the service worker activates
clientsClaim()

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing for navigation requests
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/
registerRoute(
  ({ request, url }) => {
    // Skip non-navigation requests
    if (request.mode !== "navigate") {
      return false
    }

    // Skip URLs that start with /_
    if (url.pathname.startsWith("/_")) {
      return false
    }

    // Skip URLs that look like files
    if (url.pathname.match(fileExtensionRegexp)) {
      return false
    }

    return true
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"),
)

// Cache images with a Cache-First strategy
registerRoute(
  ({ request, url }) => {
    return (
      // Cache image files
      request.destination === "image" ||
      url.pathname.endsWith(".png") ||
      url.pathname.endsWith(".jpg") ||
      url.pathname.endsWith(".jpeg") ||
      url.pathname.endsWith(".svg") ||
      url.pathname.endsWith(".gif")
    )
  },
  new CacheFirst({
    cacheName: "images",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  }),
)

// Cache CSS and JavaScript with a StaleWhileRevalidate strategy
registerRoute(
  ({ request }) => {
    return request.destination === "script" || request.destination === "style"
  },
  new StaleWhileRevalidate({
    cacheName: "static-resources",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  }),
)

// Cache API responses with a NetworkFirst strategy
registerRoute(
  ({ url }) => {
    return (
      url.pathname.startsWith("/api/") ||
      url.pathname.includes("charging-stations") ||
      url.pathname.includes("battery-check") ||
      url.pathname.includes("route-planning")
    )
  },
  new NetworkFirst({
    cacheName: "api-responses",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  }),
)

// Cache fonts with a StaleWhileRevalidate strategy
registerRoute(
  ({ request }) => {
    return request.destination === "font"
  },
  new StaleWhileRevalidate({
    cacheName: "fonts",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
)

// Handle service worker updates
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting()
  }
})

// Offline fallback
self.addEventListener("fetch", (event) => {
  // Only handle navigation requests that fail
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match("/offline.html")
      }),
    )
  }
})

// Background sync for offline form submissions
self.addEventListener("sync", (event) => {
  if (event.tag === "sync-charging-data") {
    event.waitUntil(syncChargingData())
  }
})

// Function to sync data when back online
async function syncChargingData() {
  try {
    const dataToSync = await getDataFromIndexedDB("offlineData")
    if (dataToSync && dataToSync.length) {
      for (const item of dataToSync) {
        await fetch("/api/charging-data", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(item),
        })
      }
      await clearIndexedDBStore("offlineData")
    }
  } catch (error) {
    console.error("Background sync failed:", error)
  }
}

// Helper functions for IndexedDB
async function getDataFromIndexedDB(storeName) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("evChargingDB", 1)

    request.onerror = () => reject(request.error)

    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(storeName, "readonly")
      const store = transaction.objectStore(storeName)
      const getAllRequest = store.getAll()

      getAllRequest.onsuccess = () => resolve(getAllRequest.result)
      getAllRequest.onerror = () => reject(getAllRequest.error)
    }
  })
}

async function clearIndexedDBStore(storeName) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("evChargingDB", 1)

    request.onerror = () => reject(request.error)

    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(storeName, "readwrite")
      const store = transaction.objectStore(storeName)
      const clearRequest = store.clear()

      clearRequest.onsuccess = () => resolve()
      clearRequest.onerror = () => reject(clearRequest.error)
    }
  })
}
